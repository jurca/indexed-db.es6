
import AbstractReadOnlyStorage from "./AbstractReadOnlyStorage"
import CursorDirection from "./CursorDirection"
import ReadOnlyIndex from "./ReadOnlyIndex"
import {normalizeFilter, compileOrderingFieldPaths} from "./utils"

/**
 * Allowed cursor direction values.
 */
const CURSOR_DIRECTIONS = Object.freeze([
  CursorDirection.NEXT,
  CursorDirection.PREVIOUS,
  "NEXT",
  "PREVIOUS",
  "PREV"
])

/**
 * Private field symbols.
 */
const FIELDS = Object.freeze({
  objectStore: Symbol("objectStore"),
  indexes: Symbol("indexes"),
  transactionFactory: Symbol("transactionFactory"),
  cursorConstructor: Symbol("cursorConstructor")
})

/**
 * Read-only accessor to an object store.
 */
export default class ReadOnlyObjectStore extends AbstractReadOnlyStorage {
  /**
   * Initializes the read-only object store.
   *
   * @param {IDBObjectStore} storage The native Indexed DB object store.
   * @param {function(new: ReadyOnlyCursor)} cursorConstructor Constructor of
   *        the cursor to use when traversing the storage records.
   * @param {function(): ReadOnlyTransaction} transactionFactory A function
   *        that creates and returns a new read-only transaction each time it
   *        is invoked.
   */
  constructor(storage, cursorConstructor, transactionFactory) {
    let storageFactory = () => {
      let transaction = transactionFactory()
      return transaction.getObjectStore(storage.name)
    }
    super(storage, cursorConstructor, storageFactory)

    /**
     * When {@code true}, the keys of the newly created records in this object
     * store will be automatically generated by the object store.
     *
     * The generated keys are positive integers in ascending order.
     *
     * @type {boolean}
     */
    this.autoIncrement = storage.autoIncrement

    /**
     * The names of indexed defined on this object store.
     *
     * The names are sorted in the ascending order.
     *
     * @type {string[]}
     */
    this.indexNames = Object.freeze(Array.from(storage.indexNames))

    /**
     * The native Indexed DB object store.
     *
     * @type {IDBObjectStore}
     */
    this[FIELDS.objectStore] = storage

    /**
     * Cache of created index instances.
     *
     * @type {Map<string, ReadOnlyIndex>}
     */
    this[FIELDS.indexes] = new Map()

    /**
     * A function that creates and returns a new read-only transaction each
     * time it is invoked.
     *
     * @type {function(): ReadOnlyTransaction}
     */
    this[FIELDS.transactionFactory] = transactionFactory
    
    /**
     * Constructor of the cursor to use when traversing the storage records.
     * 
     * @type {function(new: ReadyOnlyCursor)}
     */
    this[FIELDS.cursorConstructor] = cursorConstructor

    if (this.constructor === ReadOnlyObjectStore) {
      Object.freeze(this)
    }
  }

  /**
   * Retrieves the read-only index of the specified name.
   *
   * This method returns the same index object if invoked repeatedly with the
   * same name on the same instance.
   *
   * @param {string} indexName The name of the index to retrieve.
   * @return {ReadOnlyIndex} The requested index.
   */
  getIndex(indexName) {
    if (this[FIELDS.indexes].has(indexName)) {
      return this[FIELDS.indexes].get(indexName)
    }

    let nativeIndex = this[FIELDS.objectStore].index(indexName)
    let index = new ReadOnlyIndex(
      nativeIndex,
      this[FIELDS.cursorConstructor],
      this[FIELDS.transactionFactory]
    )

    this[FIELDS.indexes].set(indexName, index)

    return index
  }
  
  /**
   * Executes the specified high-level query on this object store. The method
   * will attempt to do this as efficiently as possible, however, note the
   * following situations that may impact the performance heavily:
   * 
   * - using a function as filter
   * - using an object-map of fields to values or key ranges that cannot be
   *   transformed to a single key range. This happens when the method is
   *   invoked on an object store, chooses to use an existing index instead
   *   (see below why this can happen) of running the query directly on the
   *   object store, and the fields in the filter object do not match the key
   *   path of the index; therefore this also happens if the method is used on
   *   an object store, uses the object store internally and the fields in the
   *   filter object do not match the key path of the object store.
   * - using a comparator function to specify the expected order of records.
   * - using field paths that do not have the same direction to specify the
   *   expected order of records.
   * - using field paths that do not match the key path of this object store
   *   nor the key paths of any of its indexes.
   * 
   * The sorting and filtering can be optimized by this method if the field
   * paths match the key path of the object store or the index - so the method
   * can utilize the key ranges and / or the order (implicit or reversed) of
   * the records provided by the object store or its index.
   * 
   * The methods first checks whether it can run the query on this object store
   * and optimize the record sorting and filtering. If it cannot, it checks
   * whether it can optimize the record sorting and filtering by using any of
   * the object store's indexes.
   * 
   * If both the filtering and sorting cannot be optimized, the method attempts
   * to optimize either the sorting or filtering (preffering optimizing the
   * sorting over filtering), and preferrably using this object store instead
   * of its indexes.
   * 
   * The method executes the query on this object store if neither the
   * filtering nor sorting can be optimized.
   * 
   * Note that when the sorting cannot be optimized, the method keeps the
   * semi-constructed result in a sorted array of up to {@code limit} elements,
   * inserts the current record using the insert sort algorithm and trimms the
   * end of the array if its length exceeds the {@code limit}. This allows for
   * {@code c O(n)} complexity, for {@code c} being the {@code limit}. This
   * however effectively leads to {@code O(nË†2)} complexity if {@code limit} is
   * not specified or too large.
   * 
   * @param {?(undefined|number|string|Date|Array|IDBKeyRange|Object<string, (number|string|Date|Array|IDBKeyRange)>|function(*, (number|string|Date|Array), (number|string|Date|Array)): boolean)=}
   *        filter The filter, restricting the records returned by this method.
   *        If a function is provided, the first argument will be set to the
   *        record, the second argument will be set to the primary key of the
   *        record, and the third argument will be set to the key referencing
   *        the record (the primary key if traversing an object store).
   * @param {(CursorDirection|string|string[]|function(*, *): number) order How
   *        the resulting records should be sorted. This can be one of the
   *        following:
   *        - a {@code CursorDirection} constant, either {@code NEXT} or
   *          {@code PREVIOUS} for ascending or descending order respectively
   *        - one of the {@code "NEXT"} (alias for
   *          {@code CursorDirection.NEXT}), {@code "PREVIOUS"} or
   *          {@code "PREV"} (aliases for {@code CursorDirection.PREVIOUS})
   *        - a string containing a field path, meaning the records should be
   *          sorted by the values of the denoted field (note that the field
   *          must exist in all records and its value must be a valid IndexedDB
   *          key value).
   *          The order is ascending by default, use the {@code "!" prefix} for
   *          descending order.
   *          To sort by a field named {@code NEXT}, {@code PREVIOUS} or
   *          {@code PREV} wrap the field path into an array containing the
   *          field path.
   *        - an array of field paths, as described above. The records will be
   *          sorted by the values of the specified fields lexicographically.
   *        - a comparator function compatible with the
   *          {@codelink Array.prototype.sort} method.
   * @param {number} offset The index of the first record to include in the
   *        result. The records are numbered from {@code 0}, the offset must be
   *        a non-negative integer.
   * @param {?number} limit The maximum number of records to return as a
   *        result. The limit must be a positive integer, or {@code null} if no
   *        limit should be imposed.
   * @return {PromiseSync<*[]>} A promise that resolves to the fetched records.
   */
  query(filter = null, order = CursorDirection.NEXT, offset = 0,
      limit = null) {
    if ((offset < 0) || (Math.floor(offset) !== offset)) {
      throw new Error("The offset must be a non-negative integer, " +
          `${offset} provided`)
    }
    if ((limit !== null) && ((limit <= 0) || (Math.floor(limit) !== limit))) {
      throw new Error("The limit must be a positive integer or null, " +
          `${limit} provided`)
    }
    
    let direction
    let comparator = null
    let storage = this
    if (CURSOR_DIRECTIONS.indexOf(order) > -1) {
      direction = order
    } else if (order === null) {
      direction = CursorDirection.NEXT
    } else if (order instanceof Function) {
      direction = CursorDirection.NEXT
      comparator = order
    } else {
      ({ storage, direction, comparator } = prepareQuery(this, filter, order))
    }
    
    filter = normalizeFilter(filter, storage.keyPath)
    
    let keyRange
    if (filter instanceof Function) {
      keyRange = undefined
    } else {
      keyRange = filter
      filter = null
    }
    
    return runQuery(
      storage.createCursorFactory(keyRange, direction),
      storage.multiEntry,
      filter,
      comparator,
      offset,
      limit
    )
  }
}

/**
 * Executes the specified query using the provided cursor factory.
 * 
 * @param {function(ReadyOnlyCursor): number} cursorFactory The cursor factory
 *        to use to create a cursor for executing the query.
 * @param {boolean} containsRepeatingRecords When {@code true}, a cursor
 *        created using the provided cursor factory may resolve to the same
 *        record repeatedly.
 * @param {?function(*, (number|string|Date|Array), (number|string|Date|Array)): boolean}
 *        filter Optional custom filter callback.
 * @param {?function(*, *): number} comparator Optional record comparator to
 *        use to sort the records in the result.
 * @param {number} offset The index of the first record to include in the
 *        result. The records are numbered from {@code 0}, the offset must be
 *        a non-negative integer.
 * @param {?number} limit The maximum number of records to return as a result.
 *        The limit must be a positive integer, or {@code null} if no limit
 *        should be imposed.
 */
function runQuery(cursorFactory, containsRepeatingRecords, filter, comparator,
    offset, limit) {
  let records = []
  let recordIndex = -1
  
  return cursorFactory((cursor) => {
    if (!filter && offset && ((recordIndex + 1) < offset)) {
      recordIndex = offset - 1
      cursor.advance(offset)
      return
    }
    
    let primaryKey = cursor.primaryKey
    if (filter && !filter(cursor.record, primaryKey, cursor.key)) {
      cursor.continue()
    }
    
    recordIndex++
    if (recordIndex < offset) {
      cursor.continue()
      return
    }
    
    if (containsRepeatingRecords && isRecordPresent(records, primaryKey)) {
      cursor.continue()
      return
    }
    
    if (comparator) {
      insertSorted(records, cursor.record, primaryKey, comparator)
      if (limit && (records.length > limit)) {
        records.pop()
      }
    } else {
      records.push({
        record: cursor.record,
        primaryKey
      })
    }
    
    if (!comparator && limit && (records.length >= limit)) {
      return
    }
    
    cursor.continue()
  }).then(() => records.map(recordAndKey => recordAndKey.record))
}

/**
 * Tests whether the records of the specified primary key is already present in
 * the provided array of records and their primary keys.
 * 
 * @param {{record: *, primaryKey: (number|string|Date|Array)}} records The
 *        records and their primary keys.
 * @param {(number|string|Date|Array)} recordPrimaryKey The primary key of the
 *        record to test for presence among the provided records.
 * @return {@code true} if the record with the specified primary key is already
 *         present in the records array.
 */
function isRecordPresent(records, recordPrimaryKey) {
  for (let { record, primaryKey } of records) {
    if (indexedDB.cmp(primaryKey, recordPrimaryKey) === 0) {
      return true
    }
  }
  
  return false
}

/**
 * Prepares the query that uses the specified filter and record order for
 * execution on this storage.
 * 
 * The method attempts uses a heuristic to determine whether the query should
 * be run directly on this object store or on one of its indexes for maximum
 * performance.
 * 
 * If the method cannot optimize sorting and filtering, it preferrs optimizing
 * sorting to optimizing filtering, as optimizing sorting allows the query
 * executor to skip the requested amoung of records and the records following
 * the last record that fills the required amount of records.
 * 
 * If the sorting cannot be optimized, the method attempts to optimize
 * filtering so that the matching records can be selected by providing a key
 * range to cursor, so that only the matching records will be traversed.
 * 
 * The method constructs the filtering predicate and sorting comparator if
 * neither the sorting nor filtering can be optimized, and prepares the query
 * to be executed directly on the object store.
 * 
 * @param {ReadOnlyObjectStore} thisStorage This object store.
 * @param {?(undefined|number|string|Date|Array|IDBKeyRange|Object<string, (number|string|Date|Array|IDBKeyRange)>|function(*, (number|string|Date|Array), (number|string|Date|Array)): boolean)=}
 *        filter The filter, restricting the records returned by this method.
 *        If a function is provided, the first argument will be set to the
 *        record, the second argument will be set to the primary key of the
 *        record, and the third argument will be set to the key referencing the
 *        record (the primary key if traversing an object store).
 * @param {(string|string[])} order Field paths by which the records should be
 *        sorted. A field path may be prefixed by an exclamation mark
 *        ({@code "!"}) for descending order.
 * @return {{storage: AbstractReadOnlyStorage, direction: CursorDirection, comparator: ?function(*, *): number}}
 *         The storage on which the query should be executed, the direction in
 *         which the cursor should be opened and the record comparator to use
 *         to additionally sort the fetched records matching the filter.
 */
function prepareQuery(thisStorage, filter, order) {
  order = normalizeKeyPath(order)
  
  let expectedSortingDirection = order[0].charAt(0) === "!"
  let canOptimizeOrder = canOptimizeSorting(expectedSortingDirection, order)
  
  let storages = new Map()
  storages.put(normalizeKeyPath(thisStorage.keyPath), {
    storage: thisStorage,
    score: 1 // traversing storage is faster than fetching records by index
  })
  
  for (let indexName of thisStorage.indexNames) {
    let index = thisStorage.getIndex(indexName)
    storages.push(normalizeKeyPath(index.keyPath), {
      storage: index,
      score: 0
    })
  }
  
  let simplifiedOrderFieldPaths = simplifyOrderingFieldPaths(order)
  
  if (canOptimizeOrder) {
    for (let [keyPath, storageAndScore] of storages) {
      if (indexedDB.cmp(keyPath, simplifiedOrderFieldPaths) === 0) {
        storageAndScore.score += 4 // optimizing the sorting is more important
      }
    }
  }
  
  if (!(filter instanceof Function)) {
    for (let [keyPath, storageAndScore] of storages) {
      let normalizedFilter = normalizeFilter(filter, keyPath)
      if (!(normalizedFilter instanceof Function)) {
        storageAndScore.score += 2
      }
    }
  }
  
  let sortedStorages = Array.from(storages.values())
  sortedStorages.sort((storage1, storage2) => {
    storage2.score - storage1.score
  })
  
  let chosenStorage = sortedStorages[0]
  let optimizeSorting = canOptimizeOrder &&
      (indexedDB.cmp(chosenStorage.keyPath, simplifiedOrderFieldPaths) === 0)
  
  return {
    storage: chosenStorage,
    direction: optimizeSorting ? (
      CursorDirection[expectedSortingDirection ? "PREVIOUS" : "NEXT"]
    ) : CursorDirection.NEXT,
    comparator: optimizeSorting ? null : compileOrderingFieldPaths(order)
  }
}

/**
 * Simplifies the provided ordering field paths by stripping their direction
 * prefix (if present). This allows for comparing with storage key paths.
 * 
 * @param {string[]} order The ordering field paths specifying how the records
 *        should be sorted.
 * @return {string[]} Raw field paths compatible with storage key paths.
 */
function simplifyOrderingFieldPaths(order) {
  return order.map((fieldPath) => {
    return fieldPath.replace(/^!/, "")
  })
}

/**
 * Determines whether the sorting of the query result can be done through an
 * index (provided such index exists) or the natural order of the records in
 * the object store.
 * 
 * @param {string[]} order Ordering field paths specifying how the records
 *        should be sorted.
 * @return {boolean} {@code true} if the sorting can be optimized, if an
 *         appropriate index exists or the natural order of the records in the
 *         object store matches the order denoted by the field paths.
 */
function canOptimizeSorting(expectedSortingDirection, order) {
  for (let orderingFieldPath of order) {
    if ((orderingFieldPath.charAt(0) === "!") !== expectedSortingDirection) {
      return false
    }
  }
  
  return true
}

/**
 * Normalized the provided key path into an array of field paths.
 * 
 * @param {(string|string[])} keyPath The key path to normalize.
 * @return {string[]} The normalized key path.
 */
function normalizeKeyPath(keyPath) {
  if (typeof keyPath === "string") {
    return [keyPath]
  }
  
  return keyPath
}

/**
 * Inserts the provided record into the sorted array of records and their
 * primary keys, keeping it sorted.
 * 
 * @param {*[]} records The array of records into which the provided record
 *        should be inserted.
 * @param {*} record The record to insert into the records array.
 * @param {(number|string|Date|Array)} primaryKey The primary key of the
 *        record.
 * @param {function(*, *): number} comparator Record comparator by which the
 *        array is sorted. The comparator is a standard comparator function
 *        compatible with the {@codelink Array.prototype.sort} method.
 */
function insertSorted(records, record, primaryKey, comparator) {
  for (let i = 0; i < records.length; i++) {
    let comparison = comparator(records[i], record)
    if (comparison > 0) {
      records.splice(i, 0, {
        record,
        primaryKey
      })
      return
    }
  }
  
  records.push(record)
}
